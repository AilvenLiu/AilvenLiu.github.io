---
layout:     post
title:      操作系统常见问题合集          
subtitle:   操作系统               
date:       2022-04-21
author:     OUC_LiuX
header-img: img/wallpic02.jpg
catalog: true
tags:          
    - CS basis
---      

## Backtrace 是怎么产生的           
backtrace 的实现依赖于栈指针（fp寄存器），FP寄存器保存的是上一个函数的栈底，然后一层层出栈即可得到函数调用过程。在gcc编译过程中任何非零的优化等级（-On参数）或加入了栈指针优化参数 `-fomit-frame-pointer` 后多将不能正确得到程序栈信息。    


## 什么是原子性       
原子性是指一个或者多个操作在 CPU 执行的过程中不被中断的特性，要么完整执行成功，要么退回到初始状态，，不能只执行到一半。           


## CAS 是什么东西         
CAS(Compare And Swap) 是一种无锁实现原子性数据更新的算法。具体而言，CAS 机制中有三个核心参数：V，A，B。其中，V 是数据对应的内存地址，A 是 V 地址对应的数据旧的期望值，B 是数据新的期望值。当线程要通过 CAS 机制修改主内存 V 中的值，则先将旧的数据期望值 A 读出到工作内存，在将新的期望值 B 写入到主内存前，先比较当前内存 V 中的数据是否等于 A，如果是，证明该内存处存储的数据没有被修改过，将 B 写入，并返回 true；否则，不作任何操作并返回 false。            

CAS 的全过程在操作系统中只由一条 `cmpxchgl` 硬件汇编指令实现，指令执行不可中断，是直接对 CPU 进行操作，从而在硬件层面保证了其原子性。但是，单单这一条指令在多核状态下依旧不能保证原子性。多和状态下需要在该指令前添加一条 `lock` 指令，该指令会锁定总线（阻止CPU通过总线读写内存，代价过高，当数据位于 L1～L3 Cache，且数据长度不超过 cache line ，则只会锁住缓存行）或 CPU 的缓存行从而保证操作的原子性。         

进一步地，如果发现数据已经被其他线程更改，就开始轮询，不断重试，直到成功修改。就是 **乐观锁** 的一种实现。         

#### CAS 的优缺点：         
优点：     
1. 保证变量操作的原子性。          
2. 并发量不是很高的情况下，使用 CAS 机制比使用锁机制效率更高。          
3. 在线程对共享资源占用时间较短的情况下，使用 CAS 机制效率更高。           

缺点：       
1. ABA 问题：假设两个线程，线程1 和线程2， 按照顺序有如下操作：         
   1） 线程1 读取内存中的数据为 A；          
   2） 线程2 修改内存中的数据为 B；        
   3） 线程2 修改内存中的数据为 A;       
   4） 线程1 堆内存中的数据执行 CAS 操作。           
   显然，内存中的数据被线程2 修改过，但是线程1 在修改前比较读出时和当前的值相等， CAS 是可以成功的。          
   该问题带来的典型隐患如 **栈顶问题** ，一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。            

   解决 ABA 问题比较有效的方案是引入版本号，内存中的值每一次发生变化，版本号都 +1， 进行 CAS 操作时不仅比较内存中的值，也比较版本号是否相等，只有当二者都未变化时，CAS 才能成功执行。           

2. 高竞争下的开销问题。实际这属于使用 CAS 实现的乐观锁的问题，在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。          

3. CAS 只能保证变量操作的原子性，无法保证整个代码块的线程安全。        


## 乐观锁，悲观锁，自旋锁，互斥锁，读写锁是些什么东西           
