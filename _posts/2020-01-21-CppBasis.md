---
layout:     post
title: C++常见问题合集
subtitle:   C++               
date:       2022-05-21
author:     OUC_LiuX
header-img: img/wallpic02.jpg
catalog: true
tags: 
    - CS basis
---      

## 基础篇        

#### C 和 C++ 有什么区别            

使用中比较直观的区别：        

1. c++ 使用 new/delete **运算符** 取代 c 中的 malloc/free **库函数**。         
   - new 的作用一是分配内存，二是调用类的构造函数；delete 同样除了释放内存外还负责调用类的析构函数。而 malloc/free 则只是分配和释放内存。于是无法使用 malloc 实例化一个对象。          
   - malloc/free 和 new/delete 都可以申请动态内存和释放内存，但是 new 可以自动分配空间大小，malloc 则需要使用 sizeof() 手动指明申请空间长度，比如申请一个长度为 length 的整型数组，new 方法只需要 `int *p = new int[10];`，而 malloc 则需要手动指明空间大小如 `int *p = (int*) malloc(sizeof(int) * length);`         
   - new 是类型安全的，因为其有类型检查功能，而 malloc 则不然，因为 malloc 只负责开辟空间，其他的一切要程序员自己负责。比如 `int *p = new float;` 无法通过编译，但是 `int *p = (int*) malloc(sizeof(float));` 则可以正常编译。    
   - malloc 并不是被淘汰的概念，在需要申请无格式的的空间的时候其仍然有用。比如我们的协程服务器项目，协程栈的申请只需要指明栈大小，具体栈是什么格式存储什么类型数据，这个让协程中的函数自行去决定，就可以用 malloc 且也只有 malloc 方便。    
2. c++ 引入了 ”引用“ 的概念 。                     
3. c++ 引入了 class 类 的概念，进而允许通过函数继承和重写实现多态。            


#### 引用和指针             
- **指针是实际的变量，有自己的一块空间；引用只是代码层面的某个元素的别名，没有独立的空间。**        
- 64位系统下使用 sizeof 查看一个指针的大小是一个 8 ( 这是由于指针要求可以存储所有地址空间，32位处理器的逻辑寻址位数是32，也即 4 个字节；64为则是 8 个字节 )，查看引用则是被引用对象的大小。           
- 指针使用过程中可以指向其他同类型对象，引用只是一个别名，就是对象本身，无法进行除对象自有以外的操作。       
- 指针可以多级使用，引用止于一层。        


#### struct 和 class 有什么区别          

c++ 中 class 和 struct 的最本质的区别，class 是引用类型，它在堆中分配空间，栈中保存的只是引用，是地址；而 struct 是值类型，在栈中分配空间。栈由操作系统管理，栈中分配的空间在生存期结束会自动释放；堆由程序员管理，堆空间需要手动释放。这也是 class 析构时需要手动 delete 分配的空间，否则会造成内存泄漏的原因。                 

**其他表象区别：**       
class 可以定义析构器，struct 则不可以；         
class 可以有显式的无参构造，struct 则不可以；        
class 的构造器不需要初始化全部字段，struct 则必须初始化所有字段；         
class 实例化时必须使用 new 关键字分配空间，struct 则不必；        
class 支持继承和多态，struct 不支持；       
接上一条，所以 struct 成员不可以用 protected 关键字修饰；      
class 适合大而复杂的数据结构，struct 适合于经常使用的一些数据组合成的新类型；     


#### 讲一讲智能指针         

智能指针是一个模板类，用以封装对象的裸指针以实现自动的内存管理。智能指针指向的对象计数为零时将自动释放 new 出来的内存，避免了内存泄露和空悬指针等问题。c++ 在 memory 头文件提供四种智能指针：             
- `auto_ptr`，独占式拥有，同一时间只能有一个智能指针可以指向同一对象。由于其不能指向数组、不能作为 STL 容器成员等缺陷，c++ 11 不再建议使用该类型智能指针。如果程序中使用了该指针，也不会报错，但是会报 warning 。           
- `unique_ptr`，独占式拥有，同一时间只能有一个智能指针可以指向同一对象，该智能指针类型对象无法进行拷贝构造或者赋值构造，但是可以通过 move 方法（`ptr1 = move(ptr2)` 将 ptr2 对其封装对象的所有权转移给 ptr1，此后 ptr2 没有有效的指向）转移其对封装裸指针的所有权。         
- `shared_ptr`，共享式拥有，允许多个智能指针同时指向同一个对象。对象每多一个智能指针，指针计数就会加一；每减少一个智能指针，计数减一；当计数减少到零，智能指针调用析构，new 出来的资源被释放。          
  `shared_ptr` 常用的一些成员函数：             
  - `release()` 提前释放对资源的所有权，调用该函数后计数减一。           
  - `use_count()` 获取引用计数。         
  - `unique()` 返回是否独占资源，也即引用计数是否为一。        
  - `swap()` 交换两个智能指针所拥有的对象。         
  - `get()` 返回对象裸指针。        
- `weak_ptr`，可以绑定到 `shared_ptr` 但是不增加对象的引用计数，用来解决当同一对象的两个 `shared_ptr` 相互引用时、引用计数永远不会降到 0 导致的死锁问题。          


#### shared_ptr 与引用计数            

1. 构造函数中计数初始化为 1；           
2. 拷贝构造函数中计数值加 1；              
3. 赋值运算符中，左边的对象引用计数减 1，右边的对象引用计数加 1；       
4. 析构函数中引用计数减 1；            
5. 赋值运算符和析构函数中，如果减 1 后计数为 0，则 delete 释放对象。            
6. shared_ptr 的引用计数可以通过 `.use_count()` 方法获取。           

**特别需要注意，如果使用智能指针管理对象，应当仅使用智能指针。** 考虑这样一种情况，首先 new 出来一个对象的裸指针，然后两个智能指针**分别**去包装这个裸指针。此时，两个智能指针的计数都是 1 。这种情况下一旦函数退出或者程序结束，两个智能指针都会尝试调用析构对象的析构函数并 delete 掉这个对象，就会发生对同一个对象 delete 两次的问题，程序就会 core dump 退出。              
另一种情况，我们手动 new 出一个对象裸指针，然后用一个智能指针去封装它，随后又手动 delete 掉这个对象。此时如果 `use_count()` 打印智能指针的引用计数，结果仍然是 1 ，虽然其所封装的对象已经消失；而且，仍然会发生两次 delete 的问题。           
所以，如果使用智能指针包装对象，应该一开始就 `shared_ptr<T> ptr(new Class());`， 而不要先 new 出一个裸指针然后在封装，后者很容易因为自己的不谨慎而发生内存管理错误，尤其在错综复杂的大型项目中。          


#### static 关键字           
- 修饰局部变量时，该变量将在静态存储区分配内存，变量生命周期与程序而非所在的函数相同，当程序结束操作系统回收空间时，该变量生命周期结束。但是变量的作用域仍然是函数局部。其意义在于，静态存储区的变量只在函数首次调用的时候初始化，后续调用不再进行初始化。也就是说static 的局部变量**具有记忆性**，本次调用完毕函数退出，下一次再进入函数时，变量仍保持着退出时的值。          
- 修饰全局变量时，该变量在静态存储区分配内存，变量生命周期依然与程序运行周期相同。全局变量加不加 static 的区别在于，static 修饰的全局变量作用域被限制在当前文件，而不加 static 的非静态全局变量作用于则是整个程序。由于被 static 关键字修饰过的变量具有文件作用域，如果程序包含多个文件的话，即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。这样就防止了同名变量的误用。          
- 修饰类的成员变量时：变量属于该类而非实例化后的对象。所有对象只维持一份拷贝，从而可以实现不同对象间的数据共享；不需要实例化即可以访问；不能在类内部初始化，一般在类外部初始化，且初始化的时候不加 static。          
- 修饰类的成员函数时：函数属于该类而非实例化后的对象。该函数不接收 this 指针，只能访问类的静态成员，且不需要实例化即可以访问。         


####  #define 和 const 有什么区别        

- 编译器的处理方式不同。`#define` 宏在与处理阶段展开为实际代码；而 `const` 常量在编译阶段赋值。      
- 类型和安全检查不同。 `#define` 宏没有类型，不作任何检查，仅仅是将代码展开；而 `const` 常量是有具体类型的。     
- 存储方式不同。`#define` 宏仅仅是文本替换，在预处理阶段即展开为实际的代码，不分配存储空间，或者说存储在程序的代码段；`const` 常量有具体的类型，会在栈中分配空间。      
- 作用域不同。`#define` 宏不受定义域限制，程序全局有效，而 `const` 常量值在其定义域内有效。        
- 功能范围不同。`#define` 宏可以用于函数，也即宏函数；结合上一条，可以使用宏讲一个很复杂的函数调用缩减为较短语句以方便调用。         


#### #define 和 typedef            
`#define` 宏和 typedef 都用来将一种复杂的写法替换成另一种简洁或者可读性高的写法，以提高程序的易读性，其区别在于             
- 执行时间不同：define 宏不是可编译的代码，只是简单的字符串替换，在预处理阶段会被展开为实际的内容；typedef 属于代码正文，在编译阶段执行，有类型检查功能。         
- 作用域不同：typedef 有作用域限定，define 不受作用域约束，只要在 define 后面使用都是正确的。         
- typedef 是代码正文，一定要加句尾分号；define 宏定义则一定不要分号。        
- c++ 11中可以用 `using xxx = yyy;` 代替 `typedef yyy xxx;`，前者个人认为更易理解。          


#### #ifdef, #ifndef , #undef, #if, #elseif 等的作用          
多用于头文件，对所包装的语句进行限定。               
比如 一个文件中写明了 `#define __XXX_H__`，如果有多个文件多级 include 了这个头文件，那这个文件的 Include 就会产生冗余。此时就可以使用 `#ifndef __XXX_H__ #define __XXX_H__ #endif` 进行限定，只有当没有发现该头文件时，才引入之。
再比如 `#define #undef`，多用于对宏定义的限定，程序只在某部分需要一个宏定义，为了防止在其他地方改宏定义生效，可以 `#define xxx sentance; #undef` 将宏定义限定在 `define` 和 `undef` 之间。            


#### volatile 的作用          

告知编译器，该关键字修饰的变量不要做优化。也即，不需要将其转移到 cpu 寄存器，每次使用的时候就访问其在内存中的位置即可。多用于多线程编程中多个线程操作一个变量的情况。   


#### 一个频繁使用的短小成员函数，应该用什么实现？优缺点如何？         

使用 `inline` 内联函数，编译器会将内联函数中的代码替换到函数被调用的地方。             

**优点：**       
- 在内联函数被调用的地方进行代码展开，省去了函数调用的时间，从而提高了程序运行效率。        
- 相比于宏函数，内联函数在代码展开时，编译器会进行语法检查或数据类型转换，更加安全。           

**缺点：**           
- 预处理展开后代码膨胀，产生更多开销。        
- 如果内联函数内代码块的运行时间比函数调用时间长得多，那么效率的提升并没有那么大。        
- 如果在编译完成后修改成员函数为内联，所有调用该函数的代码文件都需要重新编译。         
- 特别的，内联声明只是建议，是否内联由编译器决定，实际并不可控。        


#### 头文件和库文件，静态链接和动态链接         

**头文件**。稍微大型的面向对象项目中，代码通常被根据功能分成很多部分，而写到一个源文件里。通常，函数或类的声明和具体实现是分开的，头文件中包含函数的声明，简洁易读，库文件中包含函数的具体实现，可读性较差但实现高效。库文件通过头文件向外暴露接口，编译时链接器就可以根据头文件中的信息找到函数的具体实现并链接到程序的代码段中。         

**库文件**。库文件是函数具体实现的封装，通常以二进制而不是源码形式保存函数的具体实现，通过对应的头文件暴露接口。从而实现对具体实现保密的目的。通常，库文件分为静态库和动态库两种，在 linux 下前者后缀 `.a`，后者后缀 `.so` 。两者的**区别在于载入的时刻不同**，静态库在编译时就全部被装载进可执行程序中，动态库在编译时仅做引用，在运行时动态载入内存：          
- 静态库在编译时就被编译进了可执行程序，生成可执行文件后删除库文件，程序仍可运行。         
- 动态库被编译进可执行程序的只有函数接口，运行时在库里加载具体功能。如果删除库文件，将导致程序无法运行。            
- 静态库由于是静态嵌入，程序运行速度较快，但是程序体积较大，不易更新和维护，升级的话需要重新编译。          
- 动态库由于是运行时动态加载，因此程序运行速度较慢，体积较小，升级程序不需要重新编译。       
- 静态库的链接只需要将静态库文件添加到 g++ 后面即可，比如：        
  ```bash
  g++ main.cpp build/libtest.a -o helloworld
  ```           
- 动态库的链接需要指明头文件的搜索路径（目录一级）和库文件的搜索路径（文件一级）：       
  ```bash     
  g++ -I /user/local/workflow/include -L /usr/local/workflow/libs/Workflow.so *.cpp -o main
  ```          
  上面 `-I` 选项就是指定头文件的搜索路径，精确到目录一级； `-L` 项指明库文件路径，精确到具体文件一级。          


#### 变量的声明和定义，外部变量              

变量定义用于为变量分配地址和存储空间，还可以为变量指定初始值。每个变量有且仅有一个定义。比如 `int a;` 是一个定义。            
变量的声明用于向程序表明变量的类型和名字，每个变量可以在多处声明。比如 `a = 6;` 是一个声明。           

特别的，位于外部变量如 `extern int a;` ，其实是一个声明而不是定义，该语句和 	`extren a;` 等价，声明变量 a 是一个已经定义了的外部变量。外部变量的定义出现在函数的外部，如：         
```c++
void func() {
	......;
	extren a; //声明 a 是一个外部变量              
	......;
}

int a; // 定义外部变量 a 是一个 int 型变量            
```

#### 全局变量和局部变量，进程的五个数据段               

- 全局变量是整个程序都可以访问的变量，作用域是整个程序，生存期也是整个程序，程序结束时所占内存随程序被释放。         
- 局部变量是只有某个模块（函数，对象）可以访问的变量，作用域在模块内部，生存期是函数或者对象生命周期，函数退出或者对象析构时内存被释放。         
- 全局变量位于全局数据段，程序开始即被加载；局部变量位于堆栈段。            

linux 中进程拥有五个数据段，地址为从低到高一般是：代码段，数据段，BSS 段，堆段，栈段。其中，数据段、BSS 段和堆段一般是地址连续的，代码段和栈段另外存储。           
- 代码段：用来存放完成编译的**可执行文件**（而不是源文件）的操作指令。代码段需要放置在运行时被非法修改，所是以只读的。           
- 数据段：用来存放可执行文件中**已初始化**的静态变量和全局变量 。        
- BSS段：用来存放可执行文件中**未初始化**的静态变量和全局变量，全部初始化为0。变量在 BSS 段中只是占位符，不占据实际磁盘空间（可执行文件的）；        
- 堆段：由程序员手动操控，空间按需动态向高位地址增长，存放类对象即其他 new 出来的资源。         
- 栈段：由操作系统管理，空间按需动态向地位地址增长，存放函数参数值、局部变量等等。         


#### 拷贝函数 strcpy, sprintf, memcpy 的区别            

- 操作对象不同，strcpy 的两个操作对象都是字符串；sprintf 操作源对象可以是多种类型，目的对象是字符串；memcpy 的两个操作对象可以是任意可操作的内存地址，不论何种类型。      
- 执行效率不同，memcpy 最高，strcpy 次之，sprintf 最低。         
- 实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块之间的拷贝。        

#### 指针常量和常量指针               

指针常量，一个指针本身是常量，指针自身初始化后无法改变，但是可以改变指针指向的对象的值。       
常量指针，常量的指针，其指向的值无法改变，但是指针自身可以改变其指向。        
常量指针和指针常量这样区分：定义从右往左读，遇到 ptr 就是 "ptr is a"，遇到 `*` 就是 "pointer to "。于是： 
```c++
int a = 5, b = 6;
const int* ptr1 = &a; // ptr1 is a pointer to int const，ptr1 是一个指向常整型的常量指针，等效于 const a = 5; int* ptr = &a。          
int const* ptr2 = &a; // ptr2 is a pointer to const int，ptr2 是一个指向常整型的常量指针，等效于上面。        
*ptr1 = b; // 错误，该指针是一个常量指针。       
ptr1 = &b; // 可以。       

int* const ptr3 = &a; // ptr3 is a const pointer to int，ptr3 是一个指向整型的常量指针，指针自身是常量，初始化后其指向哪个地址就不能变了           
ptr3 = &b; // 不可行，指针自身是常量，指向的位置初始化后不能改变。         
*ptr3 = b;  // 可以             
```


#### 悬挂指针和野指针

- 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何变化，以至于其仍指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针。从而，delete 对象后，原指向它的指针应该使其指向 nullptr 或者其他有意义的地址。               
- 野指针：未初始化的指针称为野指针。          
- 从而应当在指针初始化之初或者对象被 delete 之后将指针指向 nullptr              






## 虚/纯虚函数、虚/纯虚析构、抽象类和动态绑定           

基类中声明为 virtual 并且在基类的一个或多个派生类中被 **重写** 的 **成员函数** ，称作虚函数。           

```c++
class Base {
public:
	virtual void fun();  // 虚函数，在基类中声明                  
};

class Son: Base {
public:
	void fun();		// 重写            
}
```

虚函数是实现多态性的主要手段之一。**多态是指用同一个函数名定义不同的函数**，这些函数具有不完全相同有比较相似的功能，这样就可以使用同样的接口访问具有不同功能的函数，实现“一个接口、多种方法”。具体地，在基类中定义一个虚函数，他的派生类继承并重写该虚函数。不同的派生类对象接收同一个信息，调用相同的函数名，但是执行各自重写的虚函数，这样就利用虚函数实现了多态。更广义的理解，重载和重定义应当也算多态，这些只是定义和概念的问题，不必细究。            

许多情况下，基类中不能对虚函数给出有意义的实现。比如一个日志输出器基类，只有当其派生出向文件或者向标准输出的有具体目的地派生类的时候，才可以给出具体有意义的实现，否则无异于虚空输出。但 **这不是说纯虚函数不可以定义，实际上纯虚函数是可以有函数体的，比如空函数体或者打印一行提示等等，只是函数体必须定义在类的外部**。基类中的虚函数只是提供一个接口标准，其面向具体场景的具体实现只能由该基类的派生类去完成。此时应当将之声明为纯虚函数。            
```c++
class Base {
public:
	virtual void fun() = 0;
};
```

**当基类中出现纯虚函数，该基类被称为抽象类。抽象类无法实例化。** 更 general 地，所有没有给出纯虚函数具体定义的类都无法实例化，也即，只有当抽象类的派生类重写纯虚函数后，该派生类才可以实例化。         

使用虚函数的一个好处是，指向派生类的基类指针可以调用派生类**重写**的虚函数；但如果派生类中只是**重定义**了基类的同名函数，则实际调用的还是基类的函数。          
```c++
class Base {
	virtual void fun1() {printf("virtual Base::fun1()\n");}
	void fun2() {printf("Base::fun2()\n");}
};

class Son: Base{
	void fun1() {printf("virtual Son::fun1()\n");}
	void fun2() {printf("Son::fun2()\n");}
}

int main(){
	Base *p = new Son();
	p -> fun1();	// virtual Son::fun1()                 
	p -> fun2(); 	// Base::fun2()          
	return 0;
}
```

基类指针执行派生类对象，虽然方便，但存在一个问题，那就是基类指针在析构时不会调用派生类中的析构函数，如果派生类有堆区属性，析构函数为调用则堆无法释放，会造成内存泄漏。可以声明基类的析构函数为需析构，这样 `delete 基类指针;` 的时候就会调用派生类的析构函数，释放派生类对象的资源。       

析构函数也可以声明为纯虚函数，但是，和普通的纯虚成员函数不同的是，**纯虚析构函数必须给出定义**（纯虚成员函数则非必须），否则编译报错。析构函数是纯虚，该类也属于抽象类，无法实例化对象。         
```c++
clas Base {
public:
	virtual ~Base() = 0;
};

Base::~Base() {printf("Base destractor\n");}
```


#### 重载、重写（覆盖）与重定义：         

**重载（overload）** ，指函数名相同，但它的参数数量、顺序或类型不同，返回值也可能不同的函数。具有以下特征：        
1. 在同一个作用域（同一个类中）；      
2. 函数名相同；         
3. 参数（数量、顺序或类型）不同；       
4. 返回值可以不同；        
5. 可虚可非虚。        


**重写（override，也称覆盖）** ，是指派生类重新定义基类的 **虚函数** ，具有如下特征：             
1. 不在同一个作用域（分别位于基类和派生类）；             
2. 函数名相同；              
3. 参数（数量、顺序或类型）相同；        
4. 返回值相同，否则报错（参数相同，基类声明为虚函数，必是重写）；      
5. 基类成员函数必须声明为 virtual，且不允许 static 静态函数重写。派生类不必要加 virtual 关键字；        
6. 重写函数的访问修饰符可以不同。如基类中 private 的成员函数，在派生类中可以被重写为 public 。     
7. 特别的，可以使用 `override` 关键字修饰派生类继承的基类虚函数，则情况派生类一定要实现该虚函数，否则无法通过编译。       
   ```c++
   class Son{
   public:
	   virtual void funFromBase() override; // 该虚函数一定要在派生类中实现，否则编译报错。     
   }
   ```


**重定义（也称隐藏）** ， 注意和重写区分：              
1. 不在同一个作用域（分别位于基类和派生类）；        
2. 函数名相同；            
3. 返回值可以不同；          
4. 参数不同（数量、类型、顺序任一），则不论是否虚函数，基类的同名函数将被隐藏。          
5. 参数相同，若为虚函数，则为重写，返回值一定要相同；若非虚函数，基类同名函数将被隐藏。      


#### 多态，重写和动态绑定           

多态是面向对象程序设计的一个重要特征，其字面理解为：一个接口，多种实现。依照这种字面理解，多肽可以分为两种：编译时多态和运行时多态。编译时多态是静态多态，因为它在编译时就可以确定调用的接口，可以通过函数重载、重定义和泛型编程实现；运行时多态是动态多台，因为它只有到具体运行到函数调用语句时才可以确定接口，只能通过虚函数重写实现。一般认为只有动态多态才算作真正的多态。        

<div align=center><img src="https://raw.githubusercontent.com/OUCliuxiang/OUCliuxiang.github.io/master/img/CSbasis/CPP01.png"></div>        

静态多态和动态多台的区别在于什么时候将函数实现和函数调用关联起来，是编译时期还是运行时。       
静态多态是指在编译期间就可以确定函数的调用地址并生产代码，比如函数重载，不同的同名函数往往只有函数名相同，其参数列表是不同的，在编译期间编译器即可以通过函数表确定具体调用哪一个实现。这种编译时多态也被叫做静态绑定。      
动态多态有三个要素缺一不可：继承、重写、基类指针指向子类对象。由于重写的虚函数在定义上函数名、返回值和参数列表完全相同，编译时无法确定具体调用哪一个实现，比如一个网络连接接口，存在为手机端和PC端两个派生类，在新的客户端连接到来之前，程序无法确定具体调用哪一个实现。这种运行时多态也被叫做动态绑定。       

**动态绑定**         
动态绑定指在程序运行时才绑定接口具体实现的行为，是多态实现的具体形式动态绑定。       
c++ 中的动态绑定通过虚函数实现，虚函数入口通过虚函数表（v-table）记录，通过虚指针 v-ptr 访问。有虚函数的类在实例化为对象时，编译器会为之创建一张虚函数表，把虚函数的函数入口放到虚函数表中；会创建一个虚指针指向虚函数表的头部。派生类会完全继承基类的虚函数表，这句话这样理解：1. 对于派生类没有重写的基类虚函数，其函数入口在虚函数表中的位置保持不变（基类中是第 n 个，派生类中还是第 n 个）；2. 对于派生类中首次出现，而基类中没有的虚函数，其排在原有虚函数后面，不会占有原有虚函数位置；3. 对于派生类中重写的虚函数，派生类重写的虚函数将替换基类虚函数的位置，比如基类虚函数表中第 n 个被重写，则派生类中重写的这个虚函数也在虚函数表第 n 个。      
这样一来，编译器实现代码中函数调用语句时只需要确定调用了哪一个虚函数（确定虚函数在虚函数表中的位置），进而确定虚指针的偏移即可。由于不同派生类中同一个虚函数在虚函数表中的相对位置、也即是虚指针的偏移量都是一样的，则实际调用哪个实现可依具体情况（基类指针指向了哪一个派生类对象）而定。        



## const 修饰类中成员函数的函数体         

如果一个成员函数不会或者不应该修改类内成员变量（通过任何方式，包括调用非 const 成员函数），则应将其声明为 const ，在函数声明后面加上 const 关键字。如果声明为 const 的成员函数中出现了修改成员变量或者调用非 const 成员函数的语句，则会发生编译错误。如下程序：        
```c++
class Stack{
public:
	void push(int elem);
	int pop();
	int getCount() count;
private:
	int m_num;
	int m_data[100];
};
int Stack::getCount() const {
	++ m_num;		// 企图修改成员变量，编译报错           
	pop();				  // 企图调用非 const 成员函数，编译报错          
	return m_num;
}
```

总结 const 修饰成员函数体的几点规则：       
1. const 修饰的成员函数不能访问非 const 成员函数，即使该非 const 成员函数没有修改成员变量。       
2. const 修饰的成员函数不能修改成员变量。       
3. 对于第二点，除非成员变量被 mutable 修饰。则其可以被 const 修饰的成员函数修改。       

## C++ 中的流风格 IO        

> C++ Primer 中文版， 电子工业出版社， 第五版 309 页第八章序：       
> C++ 语言不直接处理输入输出，而是通过一组定义在标准库中的类型来处理 IO。这些类型支持从设备读取数据、向设备写入数据的 IO 操作，设备可以是文件，控制台窗口等等。还有一些类型允许内存 IO，即从 string 读取数据，向 string 写入数据。       

<div align=center><img src="https://raw.githubusercontent.com/OUCliuxiang/OUCliuxiang.github.io/master/img/CSbasis/CPP02.png"></div>         

如图所示，c++ 标准库提供三个 IO 流相关头文件：`iostream`，, `fstream`, `stringstream` 分别用于通用输入输出、文件输入输出和字符串输入输出。流是一种抽象概念，它代表了数据的**无结构**化传递。按照流的方式进行输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出。       

## 


