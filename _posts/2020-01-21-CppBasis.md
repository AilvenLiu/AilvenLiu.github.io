---
layout:     post
title: C++常见问题合集
subtitle:   C++               
date:       2022-05-21
author:     OUC_LiuX
header-img: img/wallpic02.jpg
catalog: true
tags: 
    - CS basis
---      

## 基础篇        

#### C 和 C++ 有什么区别            

使用中比较直观的区别：        

1. c++ 使用 new/delete **运算符** 取代 c 中的 malloc/free **库函数**。         
   - new 的作用一是分配内存，二是调用类的构造函数；delete 同样除了释放内存外还负责调用类的析构函数。而 malloc/free 则只是分配和释放内存。于是无法使用 malloc 实例化一个对象。          
   - malloc/free 和 new/delete 都可以申请动态内存和释放内存，但是 new 可以自动分配空间大小，malloc 则需要使用 sizeof() 手动指明申请空间长度，比如申请一个长度为 length 的整型数组，new 方法只需要 `int *p = new int[10];`，而 malloc 则需要手动指明空间大小如 `int *p = (int*) malloc(sizeof(int) * length);`         
   - new 是类型安全的，因为其有类型检查功能，而 malloc 则不然，因为 malloc 只负责开辟空间，其他的一切要程序员自己负责。比如 `int *p = new float;` 无法通过编译，但是 `int *p = (int*) malloc(sizeof(float));` 则可以正常编译。    
   - malloc 并不是被淘汰的概念，在需要申请无格式的的空间的时候其仍然有用。比如我们的协程服务器项目，协程栈的申请只需要指明栈大小，具体栈是什么格式存储什么类型数据，这个让协程中的函数自行去决定，就可以用 malloc 且也只有 malloc 方便。    
2. c++ 引入了 ”引用“ 的概念 。关于引用和指针，指针是一个切实的变量，存储着指向元素的首地址，在栈内存中分配空间；引用只是一个别名，内存中不会对一个元素的引用分配空间，或者说，当声明一个引用，这个引用只是代码层面的元素的另一个名字，这个名字也指向“被引用”变量的内存地址。            
3. c++ 引入了 class 类 的概念，进而允许通过函数继承和重写实现多态。            


#### static 关键字           
- 修饰局部变量时，该变量将在静态存储区分配内存，变量生命周期与程序而非所在的函数相同，当程序结束操作系统回收空间时，该变量生命周期结束。但是变量的作用域仍然是函数局部。其意义在于，静态存储区的变量只在函数首次调用的时候初始化，后续调用不再进行初始化。也就是说static 的局部变量具有记忆性，本次调用完毕函数退出，下一次再进入函数时，变量仍保持着退出时的值。          
- 修饰全局变量时，该变量在静态存储区分配内存，变量生命周期依然与程序运行周期相同。全局变量加不加 static 的区别在于，static 修饰的全局变量作用域被限制在当前文件，而不加 static 的非静态全局变量作用于则是整个程序。由于被 static 关键字修饰过的变量具有文件作用域，如果程序包含多个文件的话，即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。这样就防止了同名变量的误用。          
- 修饰类的成员变量时：变量属于该类而非实例化后的对象。所有对象只维持一份拷贝，从而可以实现不同对象间的数据共享；不需要实例化即可以访问；不能在类内部初始化，一般在类外部初始化，且初始化的时候不加 static。          
- 修饰类的成员函数时：函数属于该类而非实例化后的对象。该函数不接收 this 指针，只能访问类的静态成员，且不需要实例化即可以访问。         


####  #define 和 const 有什么区别        

- 编译器的处理方式不同。`#define` 宏在与处理阶段展开为实际代码；而 `const` 常量在编译阶段赋值。      
- 类型和安全检查不同。 `#define` 宏没有类型，不作任何检查，仅仅是将代码展开；而 `const` 常量是有具体类型的。     
- 存储方式不同。`#define` 宏仅仅是文本替换，在预处理阶段即展开为实际的代码，不分配存储空间，或者说存储在程序的代码段；`const` 常量有具体的类型，会在栈中分配空间。      
- 作用域不同。`#define` 宏不受定义域限制，程序全局有效，而 `const` 常量值在其定义域内有效。        
- 功能范围不同。`#define` 宏可以用于函数，也即宏函数；结合上一条，可以使用宏讲一个很复杂的函数调用缩减为较短语句以方便调用。         


#### 一个频繁使用的短小成员函数，应该用什么实现？优缺点如何？         

使用 `inline` 内联函数，编译器会将内联函数中的代码替换到函数被调用的地方。             

**优点：**       
- 在内联函数被调用的地方进行代码展开，省去了函数调用的时间，从而提高了程序运行效率。        
- 相比于宏函数，内联函数在代码展开时，编译器会进行语法检查或数据类型转换，更加安全。           

**缺点：**           
- 预处理展开后代码膨胀，产生更多开销。        
- 如果内联函数内代码块的运行时间比函数调用时间长得多，那么效率的提升并没有那么大。        
- 如果在编译完成后修改成员函数为内联，所有调用该函数的代码文件都需要重新编译。         
- 特别的，内联声明只是建议，是否内联由编译器决定，实际并不可控
 








#### class 和 struct 区别      

c++ 中 class 和 struct 的最本质的区别，class 是引用类型，它在堆中分配空间，栈中保存的只是引用，是地址；而 struct 是值类型，在栈中分配空间。栈由操作系统管理，栈中分配的空间在生存期结束会自动释放；堆由程序员管理，堆空间需要手动释放。这也是 class 析构时需要手动 delete 分配的空间，否则会造成内存泄漏的原因。                 

**其他表象区别：**       
class 可以定义析构器，struct 则不可以；         
class 可以有显式的无参构造，struct 则不可以；        
class 的构造器不需要初始化全部字段，struct 则必须初始化所有字段；         
class 实例化时必须使用 new 关键字分配空间，struct 则不必；        
class 支持继承和多态，struct 不支持；       
接上一条，所以 struct 成员不可以用 protected 关键字修饰；      
class 适合大而复杂的数据结构，struct 适合于经常使用的一些数据组合成的新类型；     

## 虚/纯虚函数、虚/纯虚析构、抽象类和动态绑定           

基类中声明为 virtual 并且在基类的一个或多个派生类中被 **重写** 的 **成员函数** ，称作虚函数。           

```c++
class Base {
public:
	virtual void fun();  // 虚函数，在基类中声明                  
};

class Son: Base {
public:
	void fun();		// 重写            
}
```

虚函数是实现多态性的主要手段之一。**多态是指用同一个函数名定义不同的函数**，这些函数具有不完全相同有比较相似的功能，这样就可以使用同样的接口访问具有不同功能的函数，实现“一个接口、多种方法”。具体地，在基类中定义一个虚函数，他的派生类继承并重写该虚函数。不同的派生类对象接收同一个信息，调用相同的函数名，但是执行各自重写的虚函数，这样就利用虚函数实现了多态。更广义的理解，重载和重定义应当也算多态，这些只是定义和概念的问题，不必细究。            

许多情况下，基类中不能对虚函数给出有意义的实现。比如一个日志输出器基类，只有当其派生出向文件或者向标准输出的有具体目的地派生类的时候，才可以给出具体有意义的实现，否则无异于虚空输出。但 **这不是说纯虚函数不可以定义，实际上纯虚函数是可以有函数体的，比如空函数体或者打印一行提示等等，只是函数体必须定义在类的外部**。基类中的虚函数只是提供一个接口标准，其面向具体场景的具体实现只能由该基类的派生类去完成。此时应当将之声明为纯虚函数。            
```c++
class Base {
public:
	virtual void fun() = 0;
};
```

**当基类中出现纯虚函数，该基类被称为抽象类。抽象类无法实例化。** 更 general 地，所有没有给出纯虚函数具体定义的类都无法实例化，也即，只有当抽象类的派生类重写纯虚函数后，该派生类才可以实例化。         

使用虚函数的一个好处是，指向派生类的基类指针可以调用派生类**重写**的虚函数；但如果派生类中只是**重定义**了基类的同名函数，则实际调用的还是基类的函数。          
```c++
class Base {
	virtual void fun1() {printf("virtual Base::fun1()\n");}
	void fun2() {printf("Base::fun2()\n");}
};

class Son: Base{
	void fun1() {printf("virtual Son::fun1()\n");}
	void fun2() {printf("Son::fun2()\n");}
}

int main(){
	Base *p = new Son();
	p -> fun1();	// virtual Son::fun1()                 
	p -> fun2(); 	// Base::fun2()          
	return 0;
}
```

基类指针执行派生类对象，虽然方便，但存在一个问题，那就是基类指针在析构时不会调用派生类中的析构函数，如果派生类有堆区属性，析构函数为调用则堆无法释放，会造成内存泄漏。可以声明基类的析构函数为需析构，这样 `delete 基类指针;` 的时候就会调用派生类的析构函数，释放派生类对象的资源。       

析构函数也可以声明为纯虚函数，但是，和普通的纯虚成员函数不同的是，**纯虚析构函数必须给出定义**（纯虚成员函数则非必须），否则编译报错。析构函数是纯虚，该类也属于抽象类，无法实例化对象。         
```c++
clas Base {
public:
	virtual ~Base() = 0;
};

Base::~Base() {printf("Base destractor\n");}
```


#### 重载、重写（覆盖）与重定义：         

**重载（overload）** ，指函数名相同，但它的参数数量、顺序或类型不同，返回值也可能不同的函数。具有以下特征：        
1. 在同一个作用域（同一个类中）；      
2. 函数名相同；         
3. 参数（数量、顺序或类型）不同；       
4. 返回值可以不同；        
5. 可虚可非虚。        


**重写（override，也称覆盖）** ，是指派生类重新定义基类的 **虚函数** ，具有如下特征：             
1. 不在同一个作用域（分别位于基类和派生类）；             
2. 函数名相同；              
3. 参数（数量、顺序或类型）相同；        
4. 返回值相同，否则报错（参数相同，基类声明为虚函数，必是重写）；      
5. 基类成员函数必须声明为 virtual，且不允许 static 静态函数重写。派生类不必要加 virtual 关键字；        
6. 重写函数的访问修饰符可以不同。如基类中 private 的成员函数，在派生类中可以被重写为 public 。     
7. 特别的，可以使用 `override` 关键字修饰派生类继承的基类虚函数，则情况派生类一定要实现该虚函数，否则无法通过编译。       
   ```c++
   class Son{
   public:
	   virtual void funFromBase() override; // 该虚函数一定要在派生类中实现，否则编译报错。     
   }
   ```


**重定义（也称隐藏）** ， 注意和重写区分：              
1. 不在同一个作用域（分别位于基类和派生类）；        
2. 函数名相同；            
3. 返回值可以不同；          
4. 参数不同（数量、类型、顺序任一），则不论是否虚函数，基类的同名函数将被隐藏。          
5. 参数相同，若为虚函数，则为重写，返回值一定要相同；若非虚函数，基类同名函数将被隐藏。      


#### 多态，重写和动态绑定           

多态是面向对象程序设计的一个重要特征，其字面理解为：一个接口，多种实现。依照这种字面理解，多肽可以分为两种：编译时多态和运行时多态。编译时多态是静态多态，因为它在编译时就可以确定调用的接口，可以通过函数重载、重定义和泛型编程实现；运行时多态是动态多台，因为它只有到具体运行到函数调用语句时才可以确定接口，只能通过虚函数重写实现。一般认为只有动态多态才算作真正的多态。        

<div align=center><img src="https://raw.githubusercontent.com/OUCliuxiang/OUCliuxiang.github.io/master/img/CSbasis/CPP01.png"></div>        

静态多态和动态多台的区别在于什么时候将函数实现和函数调用关联起来，是编译时期还是运行时。       
静态多态是指在编译期间就可以确定函数的调用地址并生产代码，比如函数重载，不同的同名函数往往只有函数名相同，其参数列表是不同的，在编译期间编译器即可以通过函数表确定具体调用哪一个实现。这种编译时多态也被叫做静态绑定。      
动态多态有三个要素缺一不可：继承、重写、基类指针指向子类对象。由于重写的虚函数在定义上函数名、返回值和参数列表完全相同，编译时无法确定具体调用哪一个实现，比如一个网络连接接口，存在为手机端和PC端两个派生类，在新的客户端连接到来之前，程序无法确定具体调用哪一个实现。这种运行时多态也被叫做动态绑定。       

**动态绑定**         
动态绑定指在程序运行时才绑定接口具体实现的行为，是多态实现的具体形式动态绑定。       
c++ 中的动态绑定通过虚函数实现，虚函数入口通过虚函数表（v-table）记录，通过虚指针 v-ptr 访问。有虚函数的类在实例化为对象时，编译器会为之创建一张虚函数表，把虚函数的函数入口放到虚函数表中；会创建一个虚指针指向虚函数表的头部。派生类会完全继承基类的虚函数表，这句话这样理解：1. 对于派生类没有重写的基类虚函数，其函数入口在虚函数表中的位置保持不变（基类中是第 n 个，派生类中还是第 n 个）；2. 对于派生类中首次出现，而基类中没有的虚函数，其排在原有虚函数后面，不会占有原有虚函数位置；3. 对于派生类中重写的虚函数，派生类重写的虚函数将替换基类虚函数的位置，比如基类虚函数表中第 n 个被重写，则派生类中重写的这个虚函数也在虚函数表第 n 个。      
这样一来，编译器实现代码中函数调用语句时只需要确定调用了哪一个虚函数（确定虚函数在虚函数表中的位置），进而确定虚指针的偏移即可。由于不同派生类中同一个虚函数在虚函数表中的相对位置、也即是虚指针的偏移量都是一样的，则实际调用哪个实现可依具体情况（基类指针指向了哪一个派生类对象）而定。        



## const 修饰类中成员函数的函数体         

如果一个成员函数不会或者不应该修改类内成员变量（通过任何方式，包括调用非 const 成员函数），则应将其声明为 const ，在函数声明后面加上 const 关键字。如果声明为 const 的成员函数中出现了修改成员变量或者调用非 const 成员函数的语句，则会发生编译错误。如下程序：        
```c++
class Stack{
public:
	void push(int elem);
	int pop();
	int getCount() count;
private:
	int m_num;
	int m_data[100];
};
int Stack::getCount() const {
	++ m_num;		// 企图修改成员变量，编译报错           
	pop();				  // 企图调用非 const 成员函数，编译报错          
	return m_num;
}
```

总结 const 修饰成员函数体的几点规则：       
1. const 修饰的成员函数不能访问非 const 成员函数，即使该非 const 成员函数没有修改成员变量。       
2. const 修饰的成员函数不能修改成员变量。       
3. 对于第二点，除非成员变量被 mutable 修饰。则其可以被 const 修饰的成员函数修改。       

## C++ 中的流风格 IO        

> C++ Primer 中文版， 电子工业出版社， 第五版 309 页第八章序：       
> C++ 语言不直接处理输入输出，而是通过一组定义在标准库中的类型来处理 IO。这些类型支持从设备读取数据、向设备写入数据的 IO 操作，设备可以是文件，控制台窗口等等。还有一些类型允许内存 IO，即从 string 读取数据，向 string 写入数据。       

<div align=center><img src="https://raw.githubusercontent.com/OUCliuxiang/OUCliuxiang.github.io/master/img/CSbasis/CPP02.png"></div>         

如图所示，c++ 标准库提供三个 IO 流相关头文件：`iostream`，, `fstream`, `stringstream` 分别用于通用输入输出、文件输入输出和字符串输入输出。流是一种抽象概念，它代表了数据的**无结构**化传递。按照流的方式进行输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出。       

## 


