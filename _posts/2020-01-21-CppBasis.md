---
layout:     post
title: C++常见问题合集
subtitle:   C++               
date:       2022-05-21
author:     OUC_LiuX
header-img: img/wallpic02.jpg
catalog: true
tags: 
    - CS basis
---      

## 虚/纯虚函数、虚/纯虚析构、抽象类和动态绑定           

基类中声明为 virtual 并且在基类的一个或多个派生类中被 **重写** 的 **成员函数** ，称作虚函数。           

```c++
class Base {
public:
	virtual void fun();  // 虚函数，在基类中声明                  
};

class Son: Base {
public:
	void fun();		// 重写            
}
```

虚函数是实现多态性的主要手段之一。**多态是指用同一个函数名定义不同的函数**，这些函数具有不完全相同有比较相似的功能，这样就可以使用同样的接口访问具有不同功能的函数，实现“一个接口、多种方法”。具体地，在基类中定义一个虚函数，他的派生类继承并重写该虚函数。不同的派生类对象接收同一个信息，调用相同的函数名，但是执行各自重写的虚函数，这样就利用虚函数实现了多态。         

许多情况下，基类中不能对虚函数给出有意义的实现。比如一个日志输出器基类，只有当其派生出向文件或者向标准输出的有具体目的地派生类的时候，才可以给出具体有意义的实现，否则无异于虚空输出。但 **这不是说纯虚函数不可以定义，实际上纯虚函数是可以有函数体的，比如空函数体或者打印一行提示等等，只是函数体必须定义在类的外部**。基类中的虚函数只是提供一个接口标准，其面向具体场景的具体实现只能由该基类的派生类去完成。此时应当将之声明为纯虚函数。            
```c++
class Base {
public:
	virtual void fun() = 0;
};
```

**当基类中出现纯虚函数，该基类被称为抽象类。抽象类无法实例化。** 更 general 地，所有没有给出纯虚函数具体定义的类都无法实例化，也即，只有当抽象类的派生类重写纯虚函数后，该派生类才可以实例化。         

使用虚函数的一个好处是，指向派生类的基类指针可以调用派生类**重写**的虚函数；但如果派生类中只是**重定义**了基类的同名函数，则实际调用的还是基类的函数。          
```c++
class Base {
	virtual void fun1() {printf("virtual Base::fun1()\n");}
	void fun2() {printf("Base::fun2()\n");}
};

class Son: Base{
	void fun1() {printf("virtual Son::fun1()\n");}
	void fun2() {printf("Son::fun2()\n");}
}

int main(){
	Base *p = new Son();
	p -> fun1();	// virtual Son::fun1()                 
	p -> fun2(); 	// Base::fun2()          
	return 0;
}
```

基类指针执行派生类对象，虽然方便，但存在一个问题，那就是基类指针在析构时不会调用派生类中的析构函数，如果派生类有堆区属性，析构函数为调用则堆无法释放，会造成内存泄漏。可以声明基类的析构函数为需析构，这样 `delete 基类指针;` 的时候就会调用派生类的析构函数，释放派生类对象的资源。       

析构函数也可以声明为纯虚函数，但是，和普通的纯虚成员函数不同的是，**纯虚析构函数必须给出定义**（纯虚成员函数则非必须），否则编译报错。析构函数是纯虚，该类也属于抽象类，无法实例化对象。         
```c++
clas Base {
public:
	virtual ~Base() = 0;
};

Base::~Base() {printf("Base destractor\n");}
```


#### 重载、重写（覆盖）与重定义：         

**重载（overload）** ，指函数名相同，但它的参数数量、顺序或类型不同，返回值也可能不同的函数。具有以下特征：        
1. 在同一个作用域（同一个类中）；      
2. 函数名相同；         
3. 参数（数量、顺序或类型）不同；       
4. 返回值可以不同；        
5. 可虚可非虚。        


**重写（override，也称覆盖）** ，是指派生类重新定义基类的 **虚函数** ，具有如下特征：             
1. 不在同一个作用域（分别位于基类和派生类）；             
2. 函数名相同；              
3. 参数（数量、顺序或类型）相同；        
4. 返回值相同，否则报错（参数相同，基类声明为虚函数，必是重写）；      
5. 基类成员函数必须声明为 virtual，且不允许 static 静态函数重写。派生类不必要加 virtual 关键字；        
6. 重写函数的访问修饰符可以不同。如基类中 private 的成员函数，在派生类中可以被重写为 public 。     


**重定义（也称隐藏）** ， 注意和重写区分：              
1. 不在同一个作用域（分别位于基类和派生类）；        
2. 函数名相同；            
3. 返回值可以不同；          
4. 参数不同（数量、类型、顺序任一），则不论是否虚函数，基类的同名函数将被隐藏。          
5. 参数相同，若为虚函数，则为重写，返回值一定要相同；若非虚函数，基类同名函数将被隐藏。      

## const 与 const 修饰的函数体         